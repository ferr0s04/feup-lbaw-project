# EBD: Database Specification Component

**PixelMarket** envisions creating a revolutionary online marketplace that streamlines the process of buying and redeeming digital video game keys. Our platform will empower gamers around the globe by providing instant access to an extensive library of titles. By prioritizing user experience, we aim to offer a visually appealing, responsive, and intuitive interface that makes browsing, searching, and purchasing games a seamless experience.

At PixelMarket, we are committed to delivering secure transactions and immediate key delivery, ensuring that users can trust our service for reliable purchases. Our diverse catalogue will include everything from AAA titles to indie gems, catering to all types of gamers and their varying preferences. In addition to competitive pricing, we will implement community-driven features such as user reviews and wishlists, fostering an engaged community of gamers who can share recommendations and experiences.

Customer satisfaction is paramount, which is why we will provide 24/7 support to resolve any issues related to key redemption or payment processing. Our loyalty programs and seasonal sales will encourage repeat purchases, creating a thriving ecosystem for gamers looking for the best deals and latest releases.

By focusing on trust, community, and convenience, we aim to become the preferred destination for gamers seeking digital game keys, transforming their gaming experience and connecting them with the titles they love.

## A4: Conceptual Data Model

> The Conceptual Data Model contains the identification and description of the entities and relationships that are relevant to the database specification.

### 1. Class diagram

The UML diagram presents the main organizational entities, the relationships between them, attributes and their domains, and the multiplicity of relationships for the PixelMarket platform.

![Database.drawio](uploads/421e60fa737d6161e69e283505bfc25d/Database.drawio.png)

### 2. Additional Business Rules

Some restrictions that could not be conveyed on our UML diagram are the following:

BR01. Users can only apply one discount or promotion per transaction.

BR02. Usernames and passwords must only have letters, numbers, underlines or points.

BR03. Reviews must be text-only and limited to 500 characters.

BR04. Users can only have an account linked to the same email.

---

## A5: Relational Schema, validation and schema refinement

> This artifact contains the Relational Schema obtained by mapping from the Conceptual Data Model.

### 1. Relational Schema

The following relational schema provides a structured foundation for our online game marketplace platform, encompassing all necessary entities and relationships. Each relation captures essential details about users, games, transactions, and support interactions to facilitate all various platform functionalities.

<table>
<tr>
<th>Relation reference</th>
<th>Relation Compact Notation</th>
</tr>
<tr>
<td>R01</td>
<td>

User(<ins>id</ins>, name **NN**, username **NN UK**, email **NN UK**, password **NN**, bio, registrationDate **NN**)
</td>
</tr>
<tr>
<td>R02</td>
<td>

Buyer(<ins>id_user</ins> -\> User, id_shoppingCart -\> ShoppingCart **NN**)
</td>
</tr>
<tr>
<td>R03</td>
<td>

Seller(<ins>id_user</ins> -\> User, rating **NN CK** RatingRange, totalSalesNumber **NN CK** Positive, totalEarned **NN CK** Positive)

Positive -\> (\>=0)

RatingRange -\> (\>=0 AND \<=5)
</td>
</tr>
<tr>
<td>R04</td>
<td>

Administrator(<ins>id_user</ins> -\> User)
</td>
</tr>
<tr>
<td>R05</td>
<td>

Game(<ins>id</ins>, name **NN UK**, price **NN CK** Positive, releaseDate **NN DF** Today, description, rating **CK** RatingRange , stock **NN**, id_seller -\> Seller **NN**, id_operatingSystem -\> OperatingSystem **NN**, id_memoryRAM -\> MemoryRAM **NN**, id_processor -\> Processor **NN**, id_graphicsCard -\> GraphicsCard **NN**, id_storage -\> Storage **NN**)

Positive -\> (\>=0)

RatingRange -\> (\>=0 AND \<=5)
</td>
</tr>
<tr>
<td>R06</td>
<td>

Order(<ins>id</ins>, orderDate **NN DF** Today, totalPrice **NN CK** Positive, id_payment -\> Payment **NN**, id_buyer -\> Buyer **NN**)

Positive -\> (\>=0)
</td>
</tr>
<tr>
<td>R07</td>
<td>

Image(<ins>id</ins>, imagePath **NN**, id_game -\> Game **CK** GameOrImage, id_user -\> User **CK** GameOrImage)

GameOrImage -\> (id_game = NN ANS id_user = N) OR (id_game = N AND id_user NN)
</td>
</tr>
<tr>
<td>R08</td>
<td>

Payment(<ins>id</ins>, amount **NN**, paymentDate **NN DF** Today)
</td>
</tr>
<tr>
<td>R09</td>
<td>

Storage(<ins>id</ins>, storge **NN**)
</td>
</tr>
<tr>
<td>R10</td>
<td>

GraphicsCard(<ins>id</ins>, graphicsCard **NN**)
</td>
</tr>
<tr>
<td>R11</td>
<td>

Processor(<ins>id</ins>, processor **NN**)
</td>
</tr>
<tr>
<td>R12</td>
<td>

MemoryRAM(<ins>id</ins>, memoryRAM **NN**)
</td>
</tr>
<tr>
<td>R13</td>
<td>

OperatingSystem(<ins>id</ins>, operatingSystem **NN**)
</td>
</tr>
<tr>
<td>R14</td>
<td>

Category(<ins>id</ins>, categoryName **NN**)
</td>
</tr>
<tr>
<td>R15</td>
<td>

ShoppingCart(<ins>id</ins>, totalPrice **NN CK** Positive)

Positive -\> (\>=0)
</td>
</tr>
<tr>
<td>R16</td>
<td>

Notification(<ins>id</ins>, message **NN**, notificationDate **NN DF** Today, isRead **NN**, gameSoldNot -\> GameOrderDetails **NN CK** WitchNot, costumerSuportNot -\> HelpSupport **NN CK** WitchNot, priceChangeNot -\> Game **NN CK** WitchNot, productAvabilityNot -\> Game **NN CK** WitchNot, id_user -\> User)

WitchNot -\> (gameSoldNot = N AND costumerSuportNot = NN AND priceChangeNot = NN AND productAvabilityNot = NN) OR (gameSoldNot = NN AND costumerSuportNot = N AND priceChangeNot = NN AND productAvabilityNot = NN) OR (gameSoldNot = NN AND costumerSuportNot = NN AND priceChangeNot = N AND productAvabilityNot = NN) OR (gameSoldNot = NN AND costumerSuportNot = NN AND priceChangeNot = NN AND productAvabilityNot = N)
</td>
</tr>
<tr>
<td>R17</td>
<td>

HelpSupport(<ins>id</ins>, message **NN**, helpDate **NN DF** Today, type **NN CK** WitchHelp, id_buyer -\> Buyer **NN**)

WitchHelp -\> (type = CS or type = GS)
</td>
</tr>
<tr>
<td>R18</td>
<td>

GameOrderDetails(<ins>id_order</ins> -\> Order , <ins>id_game</ins> -\> Game, reviewRating, reviewComment, reviewDate, rating **CK** RatingRange, purchasePrice **NN CK** Positive)

Positive -\> (\>=0)

RatingRange -\> (\>=0 AND \<=5)
</td>
</tr>
<tr>
<td>R19</td>
<td>

Game_Category(<ins>id_game</ins> -\> Game **NN**, <ins>id_category</ins> -\> Category **NN**)
</td>
</tr>
<tr>
<td>R20</td>
<td>

ShoppingCar_Game(<ins>id_game</ins> -\> Game **NN**, <ins>id_shoppingCart</ins> -\> ShoppingCart **NN**)
</td>
</tr>
<tr>
<td>R21</td>
<td>

Wishlist(<ins>id_buyer</ins> -\> Buyer **NN** , <ins>id_game</ins> -\> Game **NN**)
</td>
</tr>
<tr>
<td>R22</td>
<td>

CostumerSupportAdministrator(<ins>id_CS</ins> -\> HelpSupport, <ins>id_admin</ins> -\>Administrator)
</td>
</tr>
</table>

Legend:

- UK = UNIQUE KEY
- NN = NOT NULL
- DF = DEFAULT
- CK = CHECK
- N = NULL
- CS = Costumer Support
- GS = Game Support

### 2. Domains

> The specification of additional domains can also be made in a compact form, using the notation:

| Domain Name | Domain Specification |
|-------------|----------------------|
| Today | DATE DEFAULT CURRENT_DATE |

### 3. Schema validation

To validate the Relational Schema obtained from the Conceptual Model for the PixelMarket platform, all functional dependencies are identified and the normalization of all relation schemas is the following.

| **TABLE R01** | User |
|---------------|------|
| **Keys** | { id }, { email } |
| **Functional Dependencies:** |  |
| FD0101 | id → {name, username, email, password, bio, registrationDate} |
| FD0102 | email → {id, name, username, password, bio, registrationDate} |
| **NORMAL FORM** | BCNF |

| **TABLE R02** | Buyer |
|---------------|-------|
| **Keys** | { id_user } |
| **Functional Dependencies:** |  |
| FD0201 | id_user → {id_shoppingCart} |
| **NORMAL FORM** | BCNF |

| **TABLE R03** | Seller |
|---------------|--------|
| **Keys** | { id_user } |
| **Functional Dependencies:** |  |
| FD0301 | id_user → {rating, totalSalesNumber, totalEarned} |
| **NORMAL FORM** | BCNF |

| **TABLE R04** | Administrator |
|---------------|---------------|
| **Keys** | { id_user } |
| **Functional Dependencies:** |  |
| FD0401 | _none_ |
| **NORMAL FORM** | BCNF |

| **TABLE R05** | Game |
|---------------|------|
| **Keys** | { id }, { name } |
| **Functional Dependencies:** |  |
| FD0501 | id → {name, price, releaseDate, description, rating, stock, id_seller, id_operatingSystem, id_memoryRAM, id_processor, id_graphicsCard, id_storage} |
| FD0502 | name → {id, price, releaseDate, description, rating, stock, id_seller, id_operatingSystem, id_memoryRAM, id_processor, id_graphicsCard, id_storage} |
| **NORMAL FORM** | BCNF |

| **TABLE R06** | Order |
|---------------|-------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD0601 | id → {orderDate, totalPrice, id_payment, id_buyer} |
| **NORMAL FORM** | BCNF |

| **TABLE R07** | Image |
|---------------|-------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD0701 | id → {imagePath, id_game, id_user} |
| FD0702 | id_game → {imagePath} (when id_user is NULL) |
| FD0703 | id_user → {imagePath} (when id_game is NULL) |
| **NORMAL FORM** | BCNF |

| **TABLE R08** | Payment |
|---------------|---------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD0801 | id → {amount, paymentDate} |
| **NORMAL FORM** | BCNF |

| **TABLE R09** | Storage |
|---------------|---------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD0901 | id → {storage} |
| **NORMAL FORM** | BCNF |

| **TABLE R10** | GraphicsCard |
|---------------|--------------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD1001 | id → {graphicsCard} |
| **NORMAL FORM** | BCNF |

| **TABLE R11** | Processor |
|---------------|-----------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD1101 | id → {processor} |
| **NORMAL FORM** | BCNF |

| **TABLE R12** | MemoryRAM |
|---------------|-----------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD1201 | id → {memoryRAM} |
| **NORMAL FORM** | BCNF |

| **TABLE R13** | OperatingSystem |
|---------------|-----------------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD1301 | id → {operatingSystem} |
| **NORMAL FORM** | BCNF |

| **TABLE R14** | Category |
|---------------|----------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD1401 | id → {categoryName} |
| **NORMAL FORM** | BCNF |

| **TABLE R15** | ShoppingCart |
|---------------|--------------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD1501 | id → {totalPrice} |
| **NORMAL FORM** | BCNF |

| **TABLE R16** | Notification |
|---------------|--------------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD1601 | id → {message, notificationDate, isRead, gameSoldNot, costumerSuportNot, priceChangeNot, productAvabilityNot, id_user} |
| FD1602 | id → {gameSoldNot} (when costumerSuportNot, priceChangeNot, productAvabilityNot are NULL) |
| FD1603 | id → {costumerSuportNot} (when gameSoldNot, priceChangeNot, productAvabilityNot are NULL) |
| FD1604 | id → {priceChangeNot} (when gameSoldNot, costumerSuportNot, productAvabilityNot are NULL) |
| FD1605 | id → {productAvabilityNot} (when gameSoldNot, costumerSuportNot, priceChangeNot are NULL) |
| **NORMAL FORM** | BCNF |

| **TABLE R17** | HelpSupport |
|---------------|-------------|
| **Keys** | { id } |
| **Functional Dependencies:** |  |
| FD1701 | id → {message, helpDate, type, id_buyer} |
| FD1702 | id → {type} (must be either CS or GS) |
| **NORMAL FORM** | BCNF |

| **TABLE R18** | GameOrderDetails |
|---------------|------------------|
| **Keys** | { id_order, id_game } |
| **Functional Dependencies:** |  |
| FD1801 | id_order, id_game → {reviewRating, reviewComment, reviewDate, rating, purchasePrice} |
| **NORMAL FORM** | BCNF |

| **TABLE R19** | Game_Category |
|---------------|---------------|
| **Keys** | { id_game, id_category } |
| **Functional Dependencies:** |  |
| FD1901 | _none_ |
| **NORMAL FORM** | BCNF |

| **TABLE R20** | ShoppingCart_Game |
|---------------|-------------------|
| **Keys** | { id_game, id_shoppingCart } |
| **Functional Dependencies:** |  |
| FD2001 | _none_ |
| **NORMAL FORM** | BCNF |

| **TABLE R21** | Wishlist |
|---------------|----------|
| **Keys** | { id_buyer, id_game } |
| **Functional Dependencies:** |  |
| FD2101 | _none_ |
| **NORMAL FORM** | BCNF |

| **TABLE R22** | CostumerSupportAdministrator |
|---------------|------------------------------|
| **Keys** | { id_CS, id_admin } |
| **Functional Dependencies:** |  |
| FD2201 | _none_ |
| **NORMAL FORM** | BCNF |

> If necessary, description of the changes necessary to convert the schema to BCNF.\
> Justification of the BCNF.

---

## A6: Indexes, triggers, transactions and database population

> Brief presentation of the artifact goals.

### 1. Database Workload

The database workload estimates the scale and growth rate for each relation in the system, which is crucial for managing an online game marketplace's performance and scalability. By understanding the order of magnitude and growth rates, this workload assessment helps anticipate indexing needs, storage requirements, and potential bottlenecks, ensuring the database is optimized for consistent performance and smooth user experience.

| **Relation reference** | **Relation Name** | **Order of magnitude** | **Estimated growth** |
|------------------------|-------------------|------------------------|----------------------|
| R01 | User | 100k | 100 / day |
| R02 | Buyer | 100k | 100 / day |
| R03 | Seller | 5k | 5 / day |
| R04 | Admin | 50 | Low (rare changes) |
| R05 | Game | 20k | 50 / day |
| R06 | Order | 500k | 1k / day |
| R07 | Payment | 500k | 1k / day |
| R08 | Shopping Cart | 100k | 200 / day |
| R09 | Notification | 200k | 500 / day |
| R10 | Category | 500 | 1 / week |
| R11 | Customer Support | 1k | 10 / day |
| R12 | Reviews | 100k | 200 / day |
| R13 | Operating System | 500 | 1 / month |
| R14 | Storage | 500 | 1 / month |
| R15 | Memory | 500 | 1 / month |

### 2. Proposed Indices

#### 2.1. Performance Indices

To enhance performance in an online game-selling platform, key indices have been selected to optimize essential functions that impact user experience. The chosen indices focus on three critical areas: user authentication, game browsing, and notifications.

<!--Table for IDX01-->

<table>
<tr>
<th>

**Index**
</th>
<th>IDX01</th>
</tr>
<tr>
<td>

**Relation**
</td>
<td>User</td>
</tr>
<tr>
<td>

**Attribute**
</td>
<td>username</td>
</tr>
<tr>
<td>

**Type**
</td>
<td>B-tree</td>
</tr>
<tr>
<td>

**Cardinality**
</td>
<td>High</td>
</tr>
<tr>
<td>

**Clustering**
</td>
<td>No</td>
</tr>
<tr>
<td>

**Justification**
</td>
<td>

The `username` attribute is unique (UK) and frequently used for user login and profile access, both of which involve filtering by `username`. Indexing `username` allows for faster retrieval, improving login performance and access times for profile-related operations.
</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE INDEX IDX_user_username ON User USING btree (username);
```
</td>
</tr>
</table>

By indexing the `username` in the User table, we improve login and profile access speeds, ensuring efficient user authentication.

<!--Table for IDX02-->

<table>
<tr>
<th>

**Index**
</th>
<th>IDX02</th>
</tr>
<tr>
<td>

**Relation**
</td>
<td>Game</td>
</tr>
<tr>
<td>

**Attribute**
</td>
<td>id_seller, price</td>
</tr>
<tr>
<td>

**Type**
</td>
<td>B-tree</td>
</tr>
<tr>
<td>

**Cardinality**
</td>
<td>High</td>
</tr>
<tr>
<td>

**Clustering**
</td>
<td>No</td>
</tr>
<tr>
<td>

**Justification**
</td>
<td>

In the context of game browsing, filtering and sorting games by `id_seller` and `price` is a common scenario. The index on `id_seller` and `price` helps in optimizing searches when users view games listed by a specific seller or want to sort games by price, enhancing the browsing experience.
</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE INDEX IDX_game_seller_price ON Game USING btree (id_seller, price);
```
</td>
</tr>
</table>

Indexing the `id_seller` and `price` attributes in the Game table supports faster filtering and sorting, which enhances the browsing experience for buyers looking to purchase games from specific sellers or within a particular price range.

<!--Table for IDX03-->

<table>
<tr>
<th>

**Index**
</th>
<th>IDX03</th>
</tr>
<tr>
<td>

**Relation**
</td>
<td>Notification</td>
</tr>
<tr>
<td>

**Attribute**
</td>
<td>id_user, notificationDate</td>
</tr>
<tr>
<td>

**Type**
</td>
<td>B-tree</td>
</tr>
<tr>
<td>

**Cardinality**
</td>
<td>High</td>
</tr>
<tr>
<td>

**Clustering**
</td>
<td>No</td>
</tr>
<tr>
<td>

**Justification**
</td>
<td>

Users frequently retrieve their notifications, often filtered by `id_user` and sorted by `notificationDate`. This index improves performance when showing recent notifications for each user, which is a high-frequency operation.
</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE INDEX IDX_notifications_user ON Notification USING btree (id_user, notificationDate);
```
</td>
</tr>
</table>

Lastly, indexing `id_user` and `notificationDate` in the Notification table allows for quick retrieval of user-specific notifications, ensuring timely updates on sales, order statuses, and other relevant information.

#### 2.2. Full-text Search Indices

Full-text search is implemented in high-traffic areas like game listings, game reviews and support messages, allowing users to quickly search for games by title or description, search for reviews and enabling administrators to find support messages by content.

<table>
<tr>
<th>

**Index**
</th>
<th>IDX01</th>
</tr>
<tr>
<td>

**Relation**
</td>
<td>Game</td>
</tr>
<tr>
<td>

**Attribute**
</td>
<td>name, description</td>
</tr>
<tr>
<td>

**Type**
</td>
<td>GIN</td>
</tr>
<tr>
<td>

**Clustering**
</td>
<td>No</td>
</tr>
<tr>
<td>

**Justification**
</td>
<td>Enables full-text search on game names and descriptions, allowing users to find games based on keywords. Since these fields are relatively static, GIN is suitable for efficient retrieval.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
ALTER TABLE Game
ADD COLUMN tsvectors TSVECTOR;

CREATE FUNCTION game_search_update() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND (NEW.name <> OLD.name OR NEW.description <> OLD.description)) THEN
        NEW.tsvectors = (
            setweight(to_tsvector('english', NEW.name), 'A') ||
            setweight(to_tsvector('english', NEW.description), 'B')
        );
    END IF;
    RETURN NEW;
END $$ LANGUAGE plpgsql;

CREATE TRIGGER game_search_update
BEFORE INSERT OR UPDATE ON Game
FOR EACH ROW
EXECUTE PROCEDURE game_search_update();

CREATE INDEX search_idx_game ON Game USING GIN (tsvectors);
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Index**
</th>
<th>IDX02</th>
</tr>
<tr>
<td>

**Relation**
</td>
<td>GameOrderDetails</td>
</tr>
<tr>
<td>

**Attribute**
</td>
<td>reviewComment</td>
</tr>
<tr>
<td>

**Type**
</td>
<td>GIN</td>
</tr>
<tr>
<td>

**Clustering**
</td>
<td>No</td>
</tr>
<tr>
<td>

**Justification**
</td>
<td>Provides full-text search on game reviews, enabling users to find reviews based on keywords in review comments. GIN is appropriate due to the static nature of review comments.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
ALTER TABLE GameOrderDetails 
ADD COLUMN tsvectors TSVECTOR;

CREATE FUNCTION review_search_update() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.reviewComment <> OLD.reviewComment) THEN
        NEW.tsvectors = to_tsvector('english', NEW.reviewComment);
    END IF;
    RETURN NEW;
END $$ LANGUAGE plpgsql;

CREATE TRIGGER review_search_update BEFORE INSERT OR UPDATE ON GameOrderDetails FOR EACH ROW EXECUTE PROCEDURE review_search_update();

CREATE INDEX search_idx_review ON GameOrderDetails USING GIN (tsvectors);
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Index**
</th>
<th>IDX03</th>
</tr>
<tr>
<td>

**Relation**
</td>
<td>HelpSupport</td>
</tr>
<tr>
<td>

**Attribute**
</td>
<td>message</td>
</tr>
<tr>
<td>

**Type**
</td>
<td>GIN</td>
</tr>
<tr>
<td>

**Clustering**
</td>
<td>No</td>
</tr>
<tr>
<td>

**Justification**
</td>
<td>Supports full-text search on customer support messages, allowing administrators to quickly find messages based on keywords. GIN indexing is efficient for searching through support messages.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
ALTER TABLE HelpSupport
ADD COLUMN tsvectors TSVECTOR;

CREATE FUNCTION support_search_update() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.message <> OLD.message) THEN
        NEW.tsvectors = to_tsvector('english', NEW.message);
    END IF;
    RETURN NEW;
END $$ LANGUAGE plpgsql;

CREATE TRIGGER support_search_update
BEFORE INSERT OR UPDATE ON HelpSupport
FOR EACH ROW
EXECUTE PROCEDURE support_search_update();

CREATE INDEX search_idx_support ON HelpSupport USING GIN (tsvectors);
```
</td>
</tr>
</table>

### 3. Triggers

The following triggers maintain the integrity of core operations of the platform, providing reliable, rule-based automation within the database, ensuring data consistency, enforcing business rules, and enhancing user experience across the platform.

<table>
<tr>
<th>

**Trigger**
</th>
<th>TRIGGER01</th>
</tr>
<tr>
<td>

**Description**
</td>
<td>Send a notification to users who have a game in their shopping cart whenever the price of that game changes.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION notify_price_change() RETURNS TRIGGER AS
$BODY$
BEGIN
    IF OLD.price <> NEW.price THEN
        INSERT INTO Notification(message, notificationDate, isRead, priceChangeNot, id_user)
        SELECT 'The price of a product in your cart has changed.', CURRENT_DATE, FALSE, NEW.id, ShoppingCart.id_user
        FROM ShoppingCar_Game 
        INNER JOIN ShoppingCart ON ShoppingCar_Game.id_shoppingCart = ShoppingCart.id 
        WHERE ShoppingCar_Game.id_game = NEW.id;
    END IF;
    RETURN NEW;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER notify_price_change_trigger 
    AFTER UPDATE ON Game 
    FOR EACH ROW 
    WHEN (OLD.price IS DISTINCT FROM NEW.price) 
    EXECUTE PROCEDURE notify_price_change();
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Trigger**
</th>
<th>TRIGGER02</th>
</tr>
<tr>
<td>

**Description**
</td>
<td>Update Total Price in ShoppingCart whenever a game is added or removed from the cart.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION update_total_price() RETURNS TRIGGER AS $$
BEGIN
    UPDATE ShoppingCart
    SET totalPrice = (SELECT COALESCE(SUM(price), 0)
                      FROM Game g
                      JOIN ShoppingCart_Game scg ON g.id = scg.id_game
                      WHERE scg.id_shoppingCart = NEW.id_shoppingCart)
    WHERE id = NEW.id_shoppingCart;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_total_price
AFTER INSERT OR DELETE ON ShoppingCart_Game
FOR EACH ROW EXECUTE FUNCTION update_total_price();
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Trigger**
</th>
<th>TRIGGER03</th>
</tr>
<tr>
<td>

**Description**
</td>
<td>Automatically Update TotalSalesNumber and TotalEarned for Seller whenever a new order is placed.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION update_seller_stats() RETURNS TRIGGER AS $$
BEGIN
    UPDATE Seller
    SET totalSalesNumber = totalSalesNumber + 1,
        totalEarned = totalEarned + NEW.totalPrice
    WHERE id_user = (SELECT id_seller FROM Game WHERE id = (SELECT id_game FROM GameOrderDetails WHERE id_order = NEW.id));

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_seller_stats
AFTER INSERT ON Orders
FOR EACH ROW EXECUTE FUNCTION update_seller_stats();
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Trigger**
</th>
<th>TRIGGER04</th>
</tr>
<tr>
<td>

**Description**
</td>
<td>Update Seller Rating on New Review Insertion.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION update_seller_rating() RETURNS TRIGGER AS $$
DECLARE
    v_id_seller INTEGER;
BEGIN
    -- Fetch the id_seller from the Game table
    SELECT id_seller INTO v_id_seller
    FROM Game
    WHERE id = NEW.id_game;

    -- Update the average rating for the seller
    UPDATE Seller
    SET rating = (SELECT AVG(reviewRating) FROM GameOrderDetails god
                  JOIN Game g ON god.id_game = g.id
                  WHERE g.id_seller = v_id_seller AND reviewRating IS NOT NULL)
    WHERE id_user = v_id_seller;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_seller_rating
AFTER INSERT OR UPDATE ON GameOrderDetails
FOR EACH ROW EXECUTE FUNCTION update_seller_rating();
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Trigger**
</th>
<th>TRIGGER05</th>
</tr>
<tr>
<td>

**Description**
</td>
<td>Send a notification to the seller whenever a game is sold.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION send_game_sold_notification() RETURNS TRIGGER AS $$
DECLARE
    v_id_user INTEGER;
BEGIN
    -- Fetch the id_user (id_seller)
    SELECT id_seller INTO v_id_user
    FROM Game
    WHERE id = NEW.id_game;

    -- Insert notification
    INSERT INTO Notification (message, notificationDate, isRead, id_order, id_game, id_user)
    VALUES ('A game has been sold', NOW(), FALSE, NEW.id_order, NEW.id_game, v_id_user);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_send_game_sold_notification
AFTER INSERT ON GameOrderDetails
FOR EACH ROW EXECUTE FUNCTION send_game_sold_notification();
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Trigger**
</th>
<th>TRIGGER06</th>
</tr>
<tr>
<td>

**Description**
</td>
<td>Send a notification to users who have a game in their wishlist whenever the game becomes available.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION send_product_availability_notification() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO Notification (message, notificationDate, isRead, productAvabilityNot, id_user)
    SELECT 'Game ' || NEW.name || ' is now available', NOW(), FALSE, NEW.id, id_user
    FROM Wishlist
    WHERE id_game = NEW.id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_send_product_availability_notification
AFTER UPDATE OF stock ON Game
FOR EACH ROW
WHEN (NEW.stock > 0 AND OLD.stock = 0)
EXECUTE FUNCTION send_product_availability_notification();
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Trigger**
</th>
<th>TRIGGER07</th>
</tr>
<tr>
<td>

**Description**
</td>
<td>Send a notification to users about responses to their customer support inquiries.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION send_customer_support_notification() RETURNS TRIGGER AS $$
DECLARE
    v_id_buyer INTEGER;
BEGIN
    -- Fetch the id_buyer from the HelpSupport table
    SELECT id_buyer INTO v_id_buyer
    FROM HelpSupport
    WHERE id = NEW.id_CS;

    -- Insert notification
    INSERT INTO Notification (message, notificationDate, isRead, costumerSuportNot, id_user)
    VALUES ('Response to your customer support inquiry', NOW(), FALSE, NEW.id_CS, v_id_buyer);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_send_customer_support_notification
AFTER INSERT ON CostumerSupportAdministrator
FOR EACH ROW EXECUTE FUNCTION send_customer_support_notification();
```
</td>
</tr>
</table>

<table>
<tr>
<th>

**Trigger**
</th>
<th>TRIGGER08</th>
</tr>
<tr>
<td>

**Description**
</td>
<td>Automatically update the average rating for a game whenever a new review is added.</td>
</tr>
<tr>
<td>

`SQL code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION update_game_rating() RETURNS TRIGGER AS $$
BEGIN
    -- Update the average rating for the game
    UPDATE Game
    SET rating = (SELECT AVG(reviewRating) 
                  FROM GameOrderDetails 
                  WHERE id_game = NEW.id_game 
                  AND reviewRating IS NOT NULL)
    WHERE id = NEW.id_game;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_game_rating
AFTER INSERT OR UPDATE OF reviewRating ON GameOrderDetails
FOR EACH ROW EXECUTE FUNCTION update_game_rating();
```
</td>
</tr>
</table>

### 4. Transactions

> By using transactions with appropriate isolation levels, we can prevent issues like lost updates, phantom reads, and non-repeatable reads, which are essential when managing inventory and order records during game purchases and listings.

#### Transaction 1

<table>
<tr>
<th>SQL Reference</th>
<th>Buying a game, updating stock and creating an entry order</th>
</tr>
<tr>
<td>Justification</td>
<td>

In a purchase process, the stock must be checked and updated, and an order entry created. `REPEATABLE READ` prevents issues like non-repeatable reads if the stock changes mid-transaction.
</td>
</tr>
<tr>
<td>Isolation level</td>
<td>REPEATABLE READ</td>
</tr>
<tr>
<td>

`Complete SQL Code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION process_purchase(p_game_id INT, p_total_price NUMERIC, p_payment_id INT, p_buyer_id INT)
RETURNS VOID AS $$
DECLARE
    v_stock INTEGER;
BEGIN
    -- Start transaction with repeatable read isolation level
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

    -- Check stock
    SELECT stock INTO v_stock
    FROM Game 
    WHERE id = p_game_id;

    -- Ensure there is enough stock before proceeding
    IF v_stock > 0 THEN
        -- Update stock
        UPDATE Game
        SET stock = stock - 1
        WHERE id = p_game_id AND stock > 0;

        -- Insert order
        INSERT INTO Orders (orderDate, totalPrice, id_payment, id_buyer)
        VALUES (NOW(), p_total_price, p_payment_id, p_buyer_id);

        COMMIT;
    ELSE
        RAISE EXCEPTION 'Insufficient stock for game id %', p_game_id;
    END IF;
END;
$$ LANGUAGE plpgsql;
```
</td>
</tr>
</table>

#### Transaction 2

<table>
<tr>
<th>SQL Reference</th>
<th>Announcing a game for sale by creating a new game entry in the Game table and associating categories</th>
</tr>
<tr>
<td>Justification</td>
<td>Listing a game involves inserting into multiple tables, so it must be atomic to avoid issues like inconsistent data if one part fails. SERIALIZABLE prevents phantom reads and ensures data consistency.</td>
</tr>
<tr>
<td>Isolation level</td>
<td>SERIALIZABLE</td>
</tr>
<tr>
<td>

`Complete SQL Code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION list_game(
    p_name TEXT, p_price NUMERIC, p_release_date TIMESTAMP, p_description TEXT, p_rating NUMERIC, p_stock NUMERIC, 
    p_id_payment INTEGER, p_id_seller INTEGER, p_id_operating_system INTEGER, p_id_memory_ram INTEGER, 
    p_id_processor INTEGER, p_id_graphics_card INTEGER, p_id_storage INTEGER, p_id_category INTEGER, 
    p_image_path TEXT
)
RETURNS VOID AS $$
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

    -- Insert game
    INSERT INTO Game (name, price, releaseDate, description, rating, stock, id_seller, 
                      id_operatingSystem, id_memoryRAM, id_processor, id_graphicsCard, id_storage)
    VALUES (p_name, p_price, p_release_date, p_description, p_rating, p_stock, p_id_seller, 
            p_id_operating_system, p_id_memory_ram, p_id_processor, p_id_graphics_card, p_id_storage);

    -- Insert related categories
    INSERT INTO Game_Category (id_game, id_category)
    VALUES (currval('Game_id_seq'), p_id_category);

    -- Insert images for the game
    INSERT INTO Image (imagePath, id_game)
    VALUES (p_image_path, currval('Game_id_seq'));

    -- Commit the transaction
    COMMIT;
END;
$$ LANGUAGE plpgsql;
```
</td>
</tr>
</table>

#### Transaction 3

<table>
<tr>
<th>SQL Reference</th>
<th>Deleting an account and anonymizing public content</th>
</tr>
<tr>
<td>Justification</td>
<td>When deleting a user account, it is crucial to ensure that all personal data and private information are permanently deleted, while public content such as reviews and comments are anonymized to maintain database integrity and comply with privacy regulations. SERIALIZABLE isolation level ensures that the transaction is executed in a way that prevents other transactions from interfering, ensuring data consistency.</td>
</tr>
<tr>
<td>Isolation level</td>
<td>SERIALIZABLE</td>
</tr>
<tr>
<td>

`Complete SQL Code`
</td>
<td>

```pgsql
CREATE OR REPLACE FUNCTION delete_user_account(p_user_id INTEGER)
RETURNS VOID AS $$
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

    -- Anonymize user
    UPDATE GameOrderDetails
    SET id_buyer = 1
    WHERE id_order IN (SELECT id FROM Orders WHERE id_buyer = p_user_id);

    -- Update orders to reflect the anonymized user
    UPDATE Orders
    SET id_buyer = 1
    WHERE id_buyer = p_user_id;

    -- Delete the user from Users table
    DELETE FROM Users
    WHERE id = p_user_id;

    -- Commit the transaction
    COMMIT;
END;
$$ LANGUAGE plpgsql;
```
</td>
</tr>
</table>

## Annex A. SQL Code

> The database scripts are included in this annex to the EBD component. The database creation script and the population script should be presented as separate elements. The creation script includes the code necessary to build (and rebuild) the database. The population script includes an amount of tuples suitable for testing and with plausible values for the fields of the database. The complete code of each script must be included in the group's git repository and links added here.

### A.1. Database schema

> The complete database creation must be included here and also as a script in the repository.

```pgsql
-----------------------------------------
-- Drop old schema
-----------------------------------------
DROP SCHEMA IF EXISTS PixelMarket CASCADE;
CREATE SCHEMA PixelMarket;
SET search_path TO PixelMarket;

DROP TABLE IF EXISTS Wishlist CASCADE;
DROP TABLE IF EXISTS ShoppingCart_Game CASCADE;
DROP TABLE IF EXISTS Game_Category CASCADE;
DROP TABLE IF EXISTS GameOrderDetails CASCADE;
DROP TABLE IF EXISTS CostumerSupportAdministrator CASCADE;
DROP TABLE IF EXISTS Notification CASCADE;
DROP TABLE IF EXISTS Orders CASCADE;
DROP TABLE IF EXISTS Image CASCADE;
DROP TABLE IF EXISTS Game CASCADE;
DROP TABLE IF EXISTS Administrator CASCADE;
DROP TABLE IF EXISTS Seller CASCADE;
DROP TABLE IF EXISTS Buyer CASCADE;
DROP TABLE IF EXISTS Users CASCADE;
DROP TABLE IF EXISTS ShoppingCart CASCADE;
DROP TABLE IF EXISTS Payment CASCADE;
DROP TABLE IF EXISTS HelpSupport CASCADE;
DROP TABLE IF EXISTS Storage CASCADE;
DROP TABLE IF EXISTS GraphicsCard CASCADE;
DROP TABLE IF EXISTS Processor CASCADE;
DROP TABLE IF EXISTS MemoryRAM CASCADE;
DROP TABLE IF EXISTS OperatingSystem CASCADE;
DROP TABLE IF EXISTS Category CASCADE;

DROP DOMAIN IF EXISTS RatingRange CASCADE;
DROP DOMAIN IF EXISTS Positive CASCADE;

-----------------------------------------
-- Types
-----------------------------------------

CREATE DOMAIN RatingRange AS NUMERIC CHECK (VALUE >= 0 AND VALUE <= 5);
CREATE DOMAIN Positive AS NUMERIC CHECK (VALUE >= 0);

-----------------------------------------
-- Tables
-----------------------------------------

-- Note that a plural 'Users' name was adopted because User is a reserved word in PostgreSQL.
CREATE TABLE Users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    username TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    bio TEXT,
    registrationDate TIMESTAMP DEFAULT CURRENT_DATE NOT NULL
);

CREATE TABLE ShoppingCart (
    id SERIAL PRIMARY KEY,
    totalPrice Positive NOT NULL
);

CREATE TABLE Buyer (
    id_user INTEGER PRIMARY KEY REFERENCES Users (id) ON DELETE CASCADE,
    id_shoppingCart INTEGER NOT NULL REFERENCES ShoppingCart (id)
);

CREATE TABLE Seller (
    id_user INTEGER PRIMARY KEY REFERENCES Users (id) ON DELETE CASCADE,
    rating RatingRange NOT NULL,
    totalSalesNumber Positive NOT NULL,
    totalEarned Positive NOT NULL
);

CREATE TABLE Administrator (
    id_user INTEGER PRIMARY KEY REFERENCES Users (id) ON DELETE CASCADE
);


CREATE TABLE Payment (
    id SERIAL PRIMARY KEY,
    amount Positive NOT NULL,
    paymentDate TIMESTAMP DEFAULT CURRENT_DATE NOT NULL
);

CREATE TABLE Storage (
    id SERIAL PRIMARY KEY,
    storage TEXT NOT NULL
);

CREATE TABLE GraphicsCard (
    id SERIAL PRIMARY KEY,
    graphicsCard TEXT NOT NULL
);

CREATE TABLE Processor (
    id SERIAL PRIMARY KEY,
    processor TEXT NOT NULL
);

CREATE TABLE MemoryRAM (
    id SERIAL PRIMARY KEY,
    memoryRAM TEXT NOT NULL
);

CREATE TABLE OperatingSystem (
    id SERIAL PRIMARY KEY,
    operatingSystem TEXT NOT NULL
);

CREATE TABLE Category (
    id SERIAL PRIMARY KEY,
    categoryName TEXT NOT NULL
);

CREATE TABLE Game (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    price Positive NOT NULL,
    releaseDate TIMESTAMP DEFAULT CURRENT_DATE NOT NULL,
    description TEXT,
    rating RatingRange,
    stock Positive NOT NULL,
    id_seller INTEGER NOT NULL REFERENCES Seller (id_user),
    id_operatingSystem INTEGER NOT NULL REFERENCES OperatingSystem (id),
    id_memoryRAM INTEGER NOT NULL REFERENCES MemoryRAM (id),
    id_processor INTEGER NOT NULL REFERENCES Processor (id),
    id_graphicsCard INTEGER NOT NULL REFERENCES GraphicsCard (id),
    id_storage INTEGER NOT NULL REFERENCES Storage (id) 
);

-- Note that a plural 'Orders' name was adopted because Order is a reserved word in PostgreSQL.
CREATE TABLE Orders (
    id SERIAL PRIMARY KEY,
    orderDate TIMESTAMP DEFAULT CURRENT_DATE NOT NULL,
    totalPrice Positive NOT NULL,
    id_payment INTEGER NOT NULL REFERENCES Payment (id),
    id_buyer INTEGER NOT NULL REFERENCES Buyer (id_user) ON DELETE CASCADE
);

CREATE TABLE Image (
    id SERIAL PRIMARY KEY,
    imagePath TEXT NOT NULL,
    id_game INTEGER REFERENCES Game (id) ON DELETE CASCADE,
    id_user INTEGER REFERENCES Users (id) ON DELETE CASCADE,
    CONSTRAINT GameOrImage CHECK ((id_game IS NOT NULL AND id_user IS NULL) OR (id_game IS NULL AND id_user IS NOT NULL))
);

CREATE TABLE GameOrderDetails (
    id_order INTEGER REFERENCES Orders (id) ON DELETE CASCADE,
    id_game INTEGER REFERENCES Game (id) ON DELETE CASCADE,
    reviewRating RatingRange,
    reviewComment TEXT,
    reviewDate TIMESTAMP,
    purchasePrice Positive NOT NULL,
    PRIMARY KEY (id_order, id_game)
);

CREATE TABLE Game_Category (
    id_game INTEGER NOT NULL REFERENCES Game (id) ON DELETE CASCADE,
    id_category INTEGER NOT NULL REFERENCES Category (id) ON DELETE CASCADE,
    PRIMARY KEY (id_game, id_category)
);

CREATE TABLE ShoppingCart_Game (
    id_game INTEGER UNIQUE NOT NULL REFERENCES Game (id) ON DELETE CASCADE,
    id_shoppingCart INTEGER NOT NULL REFERENCES ShoppingCart (id) ON DELETE CASCADE,
    PRIMARY KEY (id_game, id_shoppingCart)
);

CREATE TABLE Wishlist (
    id_buyer INTEGER NOT NULL REFERENCES Buyer (id_user) ON DELETE CASCADE,
    id_game INTEGER UNIQUE NOT NULL REFERENCES Game (id) ON DELETE CASCADE,
    PRIMARY KEY (id_buyer, id_game)
);

CREATE TABLE HelpSupport (
    id SERIAL PRIMARY KEY,
    message TEXT NOT NULL,
    helpDate TIMESTAMP DEFAULT CURRENT_DATE NOT NULL,
    type TEXT CHECK (type IN ('CS', 'GS')),
    id_buyer INTEGER NOT NULL REFERENCES Buyer (id_user) ON DELETE CASCADE
);

CREATE TABLE Notification (
    id SERIAL PRIMARY KEY,
    message TEXT NOT NULL,
    notificationDate TIMESTAMP DEFAULT CURRENT_DATE NOT NULL,
    isRead BOOLEAN NOT NULL,
    id_order INTEGER REFERENCES Orders (id) ON DELETE CASCADE,
    id_game INTEGER REFERENCES Game (id) ON DELETE CASCADE,
    costumerSuportNot INTEGER REFERENCES HelpSupport (id),
    priceChangeNot INTEGER REFERENCES Game (id),
    productAvabilityNot INTEGER REFERENCES Game (id),
    id_user INTEGER NOT NULL REFERENCES Users (id),
    CONSTRAINT WitchNot CHECK (
        (id_order IS NOT NULL AND id_game IS NOT NULL AND costumerSuportNot IS NULL AND priceChangeNot IS NULL AND productAvabilityNot IS NULL) OR
        (id_order IS NULL AND id_game IS NULL AND costumerSuportNot IS NOT NULL AND priceChangeNot IS NULL AND productAvabilityNot IS NULL) OR
        (id_order IS NULL AND id_game IS NULL AND costumerSuportNot IS NULL AND priceChangeNot IS NOT NULL AND productAvabilityNot IS NULL) OR
        (id_order IS NULL AND id_game IS NULL AND costumerSuportNot IS NULL AND priceChangeNot IS NULL AND productAvabilityNot IS NOT NULL)
    )
);

CREATE TABLE CostumerSupportAdministrator (
    id_CS INTEGER NOT NULL REFERENCES HelpSupport (id) ON DELETE CASCADE,
    id_admin INTEGER NOT NULL REFERENCES Administrator (id_user)ON DELETE CASCADE,
    PRIMARY KEY (id_CS, id_admin)
);

-----------------------------------------
-- INDEXES
-----------------------------------------

CREATE INDEX IDX_user_username ON Users USING btree (username);
CREATE INDEX IDX_game_seller_price ON Game USING btree (id_seller, price);
CREATE INDEX IDX_notifications_user ON Notification USING btree (id_user, notificationDate);

-- FTS INDEXES

-----------------------------------------
-- Add column to Game to store computed ts_vectors.
ALTER TABLE Game
ADD COLUMN tsvectors TSVECTOR;

-- Create a function to automatically update ts_vectors for Game.
CREATE FUNCTION game_search_update() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND (NEW.name <> OLD.name OR NEW.description <> OLD.description)) THEN
        NEW.tsvectors = (
            setweight(to_tsvector('english', NEW.name), 'A') ||
            setweight(to_tsvector('english', NEW.description), 'B')
        );
    END IF;
    RETURN NEW;
END $$ LANGUAGE plpgsql;

-- Create trigger before insert or update on Game.
CREATE TRIGGER game_search_update
BEFORE INSERT OR UPDATE ON Game
FOR EACH ROW
EXECUTE PROCEDURE game_search_update();

-- Finally, create a GIN index for ts_vectors in Game.
CREATE INDEX search_idx_game ON Game USING GIN (tsvectors);
-----------------------------------------

-----------------------------------------
-- Add column to GameOrderDetails to store computed ts_vectors.
ALTER TABLE GameOrderDetails 
ADD COLUMN tsvectors TSVECTOR;

-- Create a function to automatically update ts_vectors for GameOrderDetails.
CREATE FUNCTION review_search_update() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.reviewComment <> OLD.reviewComment) THEN
        NEW.tsvectors = to_tsvector('english', NEW.reviewComment);
    END IF;
    RETURN NEW;
END $$ LANGUAGE plpgsql;

-- Create trigger before insert or update on GameOrderDetails.
CREATE TRIGGER review_search_update BEFORE INSERT OR UPDATE ON GameOrderDetails FOR EACH ROW EXECUTE PROCEDURE review_search_update();

-- Finally, create a GIN index for ts_vectors in GameOrderDetails.
CREATE INDEX search_idx_review ON GameOrderDetails USING GIN (tsvectors);
-----------------------------------------

-----------------------------------------
-- Add column to HelpSupport to store computed ts_vectors.
ALTER TABLE HelpSupport
ADD COLUMN tsvectors TSVECTOR;

-- Create a function to automatically update ts_vectors for HelpSupport.
CREATE FUNCTION support_search_update() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.message <> OLD.message) THEN
        NEW.tsvectors = to_tsvector('english', NEW.message);
    END IF;
    RETURN NEW;
END $$ LANGUAGE plpgsql;

-- Create trigger before insert or update on HelpSupport.
CREATE TRIGGER support_search_update
BEFORE INSERT OR UPDATE ON HelpSupport
FOR EACH ROW
EXECUTE PROCEDURE support_search_update();

-- Finally, create a GIN index for ts_vectors in HelpSupport.
CREATE INDEX search_idx_support ON HelpSupport USING GIN (tsvectors);
-----------------------------------------

-----------------------------------------
-- TRIGGERS and UDFs
-----------------------------------------

-- TRIGGER01
-- Send a notification to users who have a game in their shopping cart whenever the price of that game changes.
CREATE OR REPLACE FUNCTION notify_price_change() RETURNS TRIGGER AS
$BODY$
BEGIN
    IF OLD.price <> NEW.price THEN
        INSERT INTO Notification(message, notificationDate, isRead, priceChangeNot, id_user)
        SELECT 'The price of a product in your cart has changed.', CURRENT_DATE, FALSE, NEW.id, ShoppingCart.id_user
        FROM ShoppingCar_Game 
        INNER JOIN ShoppingCart ON ShoppingCar_Game.id_shoppingCart = ShoppingCart.id 
        WHERE ShoppingCar_Game.id_game = NEW.id;
    END IF;
    RETURN NEW;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER notify_price_change_trigger 
    AFTER UPDATE ON Game 
    FOR EACH ROW 
    WHEN (OLD.price IS DISTINCT FROM NEW.price) 
    EXECUTE PROCEDURE notify_price_change();
	
-- TRIGGER02
-- Update Total Price in ShoppingCart
CREATE OR REPLACE FUNCTION update_total_price() RETURNS TRIGGER AS $$
BEGIN
    UPDATE ShoppingCart
    SET totalPrice = (SELECT COALESCE(SUM(price), 0)
                      FROM Game g
                      JOIN ShoppingCart_Game scg ON g.id = scg.id_game
                      WHERE scg.id_shoppingCart = NEW.id_shoppingCart)
    WHERE id = NEW.id_shoppingCart;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_total_price
AFTER INSERT OR DELETE ON ShoppingCart_Game
FOR EACH ROW EXECUTE FUNCTION update_total_price();

-- TRIGGER03
-- Automatically Update TotalSalesNumber and TotalEarned for Seller
CREATE OR REPLACE FUNCTION update_seller_stats() RETURNS TRIGGER AS $$
BEGIN
    UPDATE Seller
    SET totalSalesNumber = totalSalesNumber + 1,
        totalEarned = totalEarned + NEW.totalPrice
    WHERE id_user = (SELECT id_seller FROM Game WHERE id = (SELECT id_game FROM GameOrderDetails WHERE id_order = NEW.id));

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_seller_stats
AFTER INSERT ON Orders
FOR EACH ROW EXECUTE FUNCTION update_seller_stats();

-- TRIGGER04
-- Update Seller Rating on New Review
CREATE OR REPLACE FUNCTION update_seller_rating() RETURNS TRIGGER AS $$
DECLARE
    v_id_seller INTEGER;
BEGIN
    -- Fetch the id_seller from the Game table
    SELECT id_seller INTO v_id_seller
    FROM Game
    WHERE id = NEW.id_game;

    -- Update the average rating for the seller
    UPDATE Seller
    SET rating = (SELECT AVG(reviewRating) FROM GameOrderDetails god
                  JOIN Game g ON god.id_game = g.id
                  WHERE g.id_seller = v_id_seller AND reviewRating IS NOT NULL)
    WHERE id_user = v_id_seller;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_seller_rating
AFTER INSERT OR UPDATE ON GameOrderDetails
FOR EACH ROW EXECUTE FUNCTION update_seller_rating();


-- TRIGGER05
-- Game Sold Notifications
CREATE OR REPLACE FUNCTION send_game_sold_notification() RETURNS TRIGGER AS $$
DECLARE
    v_id_user INTEGER;
BEGIN
    -- Fetch the id_user (id_seller)
    SELECT id_seller INTO v_id_user
    FROM Game
    WHERE id = NEW.id_game;

    -- Insert notification
    INSERT INTO Notification (message, notificationDate, isRead, id_order, id_game, id_user)
    VALUES ('A game has been sold', NOW(), FALSE, NEW.id_order, NEW.id_game, v_id_user);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_send_game_sold_notification
AFTER INSERT ON GameOrderDetails
FOR EACH ROW EXECUTE FUNCTION send_game_sold_notification();


-- TRIGGER06
-- Product Availability Notifications
CREATE OR REPLACE FUNCTION send_product_availability_notification() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO Notification (message, notificationDate, isRead, productAvabilityNot, id_user)
    SELECT 'Game ' || NEW.name || ' is now available', NOW(), FALSE, NEW.id, id_user
    FROM Wishlist
    WHERE id_game = NEW.id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_send_product_availability_notification
AFTER UPDATE OF stock ON Game
FOR EACH ROW
WHEN (NEW.stock > 0 AND OLD.stock = 0)
EXECUTE FUNCTION send_product_availability_notification();

-- TRIGGER07
-- Customer Support Notifications
CREATE OR REPLACE FUNCTION send_customer_support_notification() RETURNS TRIGGER AS $$
DECLARE
    v_id_buyer INTEGER;
BEGIN
    -- Fetch the id_buyer from the HelpSupport table
    SELECT id_buyer INTO v_id_buyer
    FROM HelpSupport
    WHERE id = NEW.id_CS;

    -- Insert notification
    INSERT INTO Notification (message, notificationDate, isRead, costumerSuportNot, id_user)
    VALUES ('Response to your customer support inquiry', NOW(), FALSE, NEW.id_CS, v_id_buyer);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_send_customer_support_notification
AFTER INSERT ON CostumerSupportAdministrator
FOR EACH ROW EXECUTE FUNCTION send_customer_support_notification();


-- TRIGGER08
-- Updating Game Rating on New Review
CREATE OR REPLACE FUNCTION update_game_rating() RETURNS TRIGGER AS $$
BEGIN
    -- Update the average rating for the game
    UPDATE Game
    SET rating = (SELECT AVG(reviewRating) 
                  FROM GameOrderDetails 
                  WHERE id_game = NEW.id_game 
                  AND reviewRating IS NOT NULL)
    WHERE id = NEW.id_game;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_game_rating
AFTER INSERT OR UPDATE OF reviewRating ON GameOrderDetails
FOR EACH ROW EXECUTE FUNCTION update_game_rating();

-----------------------------------------
-- Default User
-----------------------------------------
-- Create a default user with id = 1 called Anonymous
INSERT INTO Users (name, username, email, password, bio, registrationDate)
VALUES ('Anonymous', 'anonymous', 'anonymous@example.com', 'password', 'Default anonymous user', CURRENT_DATE);

-----------------------------------------
-- Transactions
-----------------------------------------
-- Buying a game, updating stock and creating an entry order
CREATE OR REPLACE FUNCTION process_purchase(p_game_id INT, p_total_price NUMERIC, p_payment_id INT, p_buyer_id INT)
RETURNS VOID AS $$
DECLARE
    v_stock INTEGER;
BEGIN
    -- Start transaction with repeatable read isolation level
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

    -- Check stock
    SELECT stock INTO v_stock
    FROM Game 
    WHERE id = p_game_id;

    -- Ensure there is enough stock before proceeding
    IF v_stock > 0 THEN
        -- Update stock
        UPDATE Game
        SET stock = stock - 1
        WHERE id = p_game_id AND stock > 0;

        -- Insert order
        INSERT INTO Orders (orderDate, totalPrice, id_payment, id_buyer)
        VALUES (NOW(), p_total_price, p_payment_id, p_buyer_id);

        COMMIT;
    ELSE
        RAISE EXCEPTION 'Insufficient stock for game id %', p_game_id;
    END IF;
END;
$$ LANGUAGE plpgsql;


-- Announcing a game for sale by creating a new game entry in the Game table and associating categories
CREATE OR REPLACE FUNCTION list_game(
    p_name TEXT, p_price NUMERIC, p_release_date TIMESTAMP, p_description TEXT, p_rating NUMERIC, p_stock NUMERIC, 
    p_id_payment INTEGER, p_id_seller INTEGER, p_id_operating_system INTEGER, p_id_memory_ram INTEGER, 
    p_id_processor INTEGER, p_id_graphics_card INTEGER, p_id_storage INTEGER, p_id_category INTEGER, 
    p_image_path TEXT
)
RETURNS VOID AS $$
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

    -- Insert game
    INSERT INTO Game (name, price, releaseDate, description, rating, stock, id_seller, 
                      id_operatingSystem, id_memoryRAM, id_processor, id_graphicsCard, id_storage)
    VALUES (p_name, p_price, p_release_date, p_description, p_rating, p_stock, p_id_seller, 
            p_id_operating_system, p_id_memory_ram, p_id_processor, p_id_graphics_card, p_id_storage);

    -- Insert related categories
    INSERT INTO Game_Category (id_game, id_category)
    VALUES (currval('Game_id_seq'), p_id_category);

    -- Insert images for the game
    INSERT INTO Image (imagePath, id_game)
    VALUES (p_image_path, currval('Game_id_seq'));

    -- Commit the transaction
    COMMIT;
END;
$$ LANGUAGE plpgsql;

-- Deleting an account and anonymizing public content
CREATE OR REPLACE FUNCTION delete_user_account(p_user_id INTEGER)
RETURNS VOID AS $$
BEGIN
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

    -- Anonymize user
    UPDATE GameOrderDetails
    SET id_buyer = 1
    WHERE id_order IN (SELECT id FROM Orders WHERE id_buyer = p_user_id);

    -- Update orders to reflect the anonymized user
    UPDATE Orders
    SET id_buyer = 1
    WHERE id_buyer = p_user_id;

    -- Delete the user from Users table
    DELETE FROM Users
    WHERE id = p_user_id;

    -- Commit the transaction
    COMMIT;
END;
$$ LANGUAGE plpgsql;

-----------------------------------------
-- End of Schema
-----------------------------------------
```

### A.2. Database population

> Only a sample of the database population script may be included here, e.g. the first 10 lines. The full script must be available in the repository.

```pgsql
-- Populate Users
INSERT INTO Users (name, username, email, password, bio, registrationDate) VALUES
('John Doe', 'johndoe', 'johndoe@example.com', 'password123', 'Gamer and developer', CURRENT_DATE),
('Jane Smith', 'janesmith', 'janesmith@example.com', 'securepass', 'Game enthusiast', CURRENT_DATE),
('Alice Johnson', 'alicej', 'alice@example.com', 'alicepass', 'Love RPG games', CURRENT_DATE),
('Bob Brown', 'bobb', 'bob@example.com', 'bobpass', 'Action game lover', CURRENT_DATE),
('Charlie Black', 'charlie', 'charlie@example.com', 'charliepass', 'Casual gamer', CURRENT_DATE);

-- Populate Administrator
INSERT INTO Administrator (id_user) VALUES
(5),
(6);

-- Populate Storage
INSERT INTO Storage (storage) VALUES
('HDD 1TB'),
('SSD 512GB');

-- Populate GraphicsCard
INSERT INTO GraphicsCard (graphicsCard) VALUES
('NVIDIA GTX 1050'),
('AMD Radeon RX 570');

-- Populate Processor
INSERT INTO Processor (processor) VALUES
('Intel i5'),
('AMD Ryzen 5');

-- Populate MemoryRAM
INSERT INTO MemoryRAM (memoryRAM) VALUES
('8GB DDR4'),
('16GB DDR4');
```

## Revision history

Changes made to the first submission:

1. Item 1
2. ..

---

GROUP2506, DD/MM/2025

* Group member 1 Filipe Esteves, up202206515@up.pt
* Group member 2 Rodrigo Sousa, up202207292@up.pt
* Group member 3 Gonçalo Miguel Dias Ferros, up202207592@up.pt
* Group member 4 Pedro Oliveira, up202206257@up.pt